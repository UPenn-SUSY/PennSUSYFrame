// Dear emacs, this is -*- c++ -*-
// -------------------------------------------------------------
//             Code produced by D3PDMakerReader
//
//  author: Attila Krasznahorkay <Attila.Krasznahorkay@cern.ch>
// -------------------------------------------------------------
#ifndef D3PDREADER_FakeD3PDObject_H
#define D3PDREADER_FakeD3PDObject_H

#include <map>
#include <vector>
using std::vector;

#include <TObject.h>
#include <TString.h>

#include "VarHandle.h"

class TTree;

namespace D3PDReader {

   /**
    * Code generated by CodeGenerator_v2 on:
    *  host = pc-penn-d-07
    *  OS   = Linux / 2.6.18-274.18.1.el5
    *  user = ehines
    *  time = Thu May  3 15:19:40 2012
    */
   class FakeD3PDObject : public TObject {

   public:
      /// Constructor used when reading from a TTree
      FakeD3PDObject( const ::Long64_t& master, const char* prefix = "" );
      /// Constructor when the object is only used for writing data out
      FakeD3PDObject( const char* prefix = "" );

      /// Get the currently configured prefix value
      const char* GetPrefix() const;
      /// Set the prefix for the variables
      void SetPrefix( const char* prefix );

      /// Connect the object to an input TTree
      void ReadFrom( ::TTree* tree );
      /// Connect the object to an output TTree
      void WriteTo( ::TTree* tree );

      /// Turn (selected) branches either on or off
      void SetActive( ::Bool_t active = kTRUE,
                      const ::TString& pattern = ".*" );
      /// Read in all the variables that we need to write out as well
      void ReadAllActive();

      /// EventNumber/i
      VarHandle< UInt_t > EventNumber;
      /// LepId
      VarHandle< vector<int>* > LepId;
      /// LepTight
      VarHandle< vector<int>* > LepTight;
      /// lepN/I
      VarHandle< Int_t > lepN;
      /// lepPx
      VarHandle< vector<float>* > lepPx;
      /// lepPy
      VarHandle< vector<float>* > lepPy;
      /// lepPz
      VarHandle< vector<float>* > lepPz;
      /// lepPt
      VarHandle< vector<float>* > lepPt;
      /// lepE
      VarHandle< vector<float>* > lepE;
      /// jetN/I
      VarHandle< Int_t > jetN;
      /// jetPx
      VarHandle< vector<float>* > jetPx;
      /// jetPy
      VarHandle< vector<float>* > jetPy;
      /// jetPz
      VarHandle< vector<float>* > jetPz;
      /// jetPt
      VarHandle< vector<float>* > jetPt;
      /// jetE
      VarHandle< vector<float>* > jetE;
      /// jetJVF
      VarHandle< vector<float>* > jetJVF;
      /// JetFitterCOMBNN
      VarHandle< vector<float>* > JetFitterCOMBNN;
      /// thisMETx/F
      VarHandle< Float_t > thisMETx;
      /// thisMETy/F
      VarHandle< Float_t > thisMETy;
      /// missingET_rel/F
      VarHandle< Float_t > missingET_rel;
      /// mt2/F
      VarHandle< Float_t > mt2;
      /// mll/F
      VarHandle< Float_t > mll;
      /// OS/I
      VarHandle< Int_t > OS;
      /// SS/I
      VarHandle< Int_t > SS;
      /// EE/I
      VarHandle< Int_t > EE;
      /// EM/I
      VarHandle< Int_t > EM;
      /// ME/I
      VarHandle< Int_t > ME;
      /// MM/I
      VarHandle< Int_t > MM;
      /// TT/I
      VarHandle< Int_t > TT;
      /// Tl/I
      VarHandle< Int_t > Tl;
      /// lT/I
      VarHandle< Int_t > lT;
      /// ll/I
      VarHandle< Int_t > ll;
      /// wgts_rr_nom
      VarHandle< vector<double>* > wgts_rr_nom;
      /// wgts_rf_nom
      VarHandle< vector<double>* > wgts_rf_nom;
      /// wgts_fr_nom
      VarHandle< vector<double>* > wgts_fr_nom;
      /// wgts_ff_nom
      VarHandle< vector<double>* > wgts_ff_nom;
      /// wgts_rr_max
      VarHandle< vector<double>* > wgts_rr_max;
      /// wgts_rf_max
      VarHandle< vector<double>* > wgts_rf_max;
      /// wgts_fr_max
      VarHandle< vector<double>* > wgts_fr_max;
      /// wgts_ff_max
      VarHandle< vector<double>* > wgts_ff_max;
      /// wgts_rr_min
      VarHandle< vector<double>* > wgts_rr_min;
      /// wgts_rf_min
      VarHandle< vector<double>* > wgts_rf_min;
      /// wgts_fr_min
      VarHandle< vector<double>* > wgts_fr_min;
      /// wgts_ff_min
      VarHandle< vector<double>* > wgts_ff_min;
      /// wgts_rr_syst_nom
      VarHandle< vector<double>* > wgts_rr_syst_nom;
      /// wgts_rf_syst_nom
      VarHandle< vector<double>* > wgts_rf_syst_nom;
      /// wgts_fr_syst_nom
      VarHandle< vector<double>* > wgts_fr_syst_nom;
      /// wgts_ff_syst_nom
      VarHandle< vector<double>* > wgts_ff_syst_nom;
      /// wgts_rr_syst_max
      VarHandle< vector<double>* > wgts_rr_syst_max;
      /// wgts_rf_syst_max
      VarHandle< vector<double>* > wgts_rf_syst_max;
      /// wgts_fr_syst_max
      VarHandle< vector<double>* > wgts_fr_syst_max;
      /// wgts_ff_syst_max
      VarHandle< vector<double>* > wgts_ff_syst_max;
      /// wgts_rr_syst_min
      VarHandle< vector<double>* > wgts_rr_syst_min;
      /// wgts_rf_syst_min
      VarHandle< vector<double>* > wgts_rf_syst_min;
      /// wgts_fr_syst_min
      VarHandle< vector<double>* > wgts_fr_syst_min;
      /// wgts_ff_syst_min
      VarHandle< vector<double>* > wgts_ff_syst_min;
      /// region
      VarHandle< vector<int>* > region;
      /// region_SIGT
      VarHandle< vector<TString>* > region_SIGT;

   private:
      std::map< ::TString, VarHandleBase* > fHandles; ///< Book-keeper of the VarHandle members
      const ::Bool_t fFromInput; ///< Flag specifying if object is used for D3PD reading
      const ::TString fPrefix; ///< Prefix to the branch names

      ClassDef( FakeD3PDObject, 0 )

   }; // class FakeD3PDObject

} // namespace D3PDReader

#endif // D3PDREADER_FakeD3PDObject_H
